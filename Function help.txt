Conmmand switches :


[Applies to each return parameter]

-h  Hexadecimal output
-s  String output
-d  Decimal output

To change default behavior, use command SetOutput [-h|-s|-d]

List of all supported functions:


ReaderOpen	:	   Open reader communication port.|Parameters No parameters required	
ReaderOpenEx	:	   Open reader communication port in several different ways. Can be used for establishing communication with COM port too.|Parameters reader_type, port_name, port_interface	
ReaderOpenByType	:	   Opens a port of connected reader using readers family type. Useful for speed up opening for non uFR basic reader type (e.g. BaseHD with uFR support).|Parameters reader_type	
ReaderReset	:	   Physical reset of reader communication port.|Parameters No parameters required	
ReaderClose	:	   Close reader communication port.|Parameters No parameters required	
ReaderStillConnected	:	   Retrieve info if reader is still connected to host.|Parameters connected	
GetReaderType	:	   Returns reader type as a pointer to 4 byte value.|Parameters lpulReaderType	
GetReaderSerialNumber	:	   Returns reader serial number as a pointer to 4 byte value.|Parameters lpulSerialNumber	
GetReaderHardwareVersion	:	   Returns reader hardware version as two byte representation of higher and lower byte.|Parameters version_major, version_minor	
GetReaderFirmwareVersion	:	   Returns reader firmware version as two byte representation of higher and lower byte.|Parameters version_major, version_minor	
GetBuildNumber	:	   Returns reader firmware build version as one byte representation.|Parameters build	
GetReaderSerialDescription	:	   Returns reader's descriptive name as a row of 8 chars.|Parameters pSerial	
ChangeReaderPassword	:	   Setting date/time of RTC|Parameters old_password, new_password	
ReaderKeyWrite	:	   Store a new key or change existing key under provided index parameter.The keys are in a special area in EEPROM that can not be read anymore which gains protection.|Parameters aucKey, ucKeyIndex	
ReaderKeysLock	:	   Lock reader's keys to prevent further changing.|Parameters password	
ReaderKeysUnlock	:	   The factory setting is that reader keys are unlocked.|Parameters password	
ReaderSoftRestart	:	   This function is used to restart the reader by software. It sets all readers parameters to default values and close RF field which resets all the cards in the field.|Parameters No parameters required	
ReadUserData	:	   User data is 16 byte long.|Parameters aucData	
WriteUserData	:	   Write user data into device's NV memory. User data is 16 byte long.|Parameters aucData	
UfrEnterSleepMode	:	   Turn device into Sleep mode.|Parameters No parameters required	
UfrEnterSleepMode	:	   Function allows enter to reader low power working mode. Reader is in sleep mode. RF field is turned off. The reader is waiting for the command to return to normal working mode.|Parameters No parameters required	
UfrLeaveSleepMode	:	   Wake up device from Sleep mode.|Parameters No parameters required	
UfrLeaveSleepMode	:	   Function allows return from low power reader mode to normal working mode.|Parameters No parameters required	
AutoSleepSet	:	   Turn device into Sleep mode after certain amount of time.|Parameters seconds_wait	
AutoSleepGet	:	   Get status of AutoSleep mode.|Parameters seconds_wait	
SetSpeedPermanently	:	   Store a new key or change existing key under provided index parameter.The keys are in a special area in EEPROM that can not be read anymore which gains protection.|Parameters tx_speed, rx_speed	
SetSpeedPermanently	:	   SetSpeedPermanently|Parameters tx_speed, rx_speed	
GetSpeedParameters	:	   Returns baud rate configured with previous function.|Parameters tx_speed, rx_speed	
SetAsyncCardIdSendConfig	:	   Function sets configuration parameters for this feature.|Parameters send_enable, prefix_enable, prefix, suffix, send_removed_enable, async_baud_rate	
GetAsyncCardIdSendConfig	:	   Returns info about parameters configured with previous function.|Parameters send_enable, prefix_enable, prefix, suffix, send_removed_enable, async_baud_rate	
SetAsyncCardIdSendConfigEx	:	   Function sets configuration parameters for this feature.|Parameters send_enable, prefix_enable, prefix, suffix, send_removed_enable, reverse_byte_order, decimal_representation, async_baud_rate	
GetAsyncCardIdSendConfigEx	:	   Returns info about parameters configured with previous function.|Parameters send_enable, prefix_enable, prefix, suffix, send_removed_enable, reverse_byte_order, decimal_representation, async_baud_rate	
ReaderUISignal	:	   This function turns sound and light reader signals. Sound signals are performed by readers buzzer and light signals are performed by readers LEDs.|Parameters light_signal_mode, beep_signal_mode	
UfrRedLightControl	:	   If light_status, value is 1, red light will be constantly turned on until receive light_status value 0.|Parameters light_status	
SetSpeakerFrequency	:	   This function plays constant sound of frequency Hertz|Parameters frequency	
GetDlogicCardType	:	   This function returns card type according to DlogicCardType enumeration|Parameters lpucCardType	
GetNfcT2TVersion	:	   This function returns 8 bytes of the T2T version. All modern T2T chips support this functionality and have in common a total of 8 byte long version response. This function is primarily intended to use with NFC_T2T_GENERIC tags (i.e. tags which return 0x0C in the *lpucCardType parameter of the GetDlogicCardType()).|Parameters lpucVersionResponse	
GetCardIdEx	:	   This function returns UID of card actually present in RF field of reader. It can handle all three known types : 4, 7 and 10 byte long UIDs.|Parameters lpucSak, aucUid, lpucUidSize	
GetCardId	:	   This function returns UID of card actually present in RF field of reader. It can handle all three known types : 4, 7 and 10 byte long UIDs.|Parameters lpucSak, aucUid, lpucUidSize	
GetLastCardIdEx	:	   Returns card UID as a 4-byte array. This function is deprecated and used only for backward compatibility with older firmware versions (before v2.0). We strongly discourage use of this function. This function cant successfully handle 7 byte UIDS.|Parameters lpucCardType, lpucCardSerial	
BlockRead	:	   Read particular block using absolute Block address.|Parameters data, block_address, auth_mode, key_index	
BlockRead_AKM1	:	   Read particular block using absolute Block address.|Parameters data, block_address, auth_mode	
BlockRead_AKM2	:	   Read particular block using absolute Block address.|Parameters data, block_address, auth_mode	
BlockRead_PK	:	   Read particular block using absolute Block address.|Parameters data, block_address, auth_mode, key	
BlockWrite	:	   Write particular block using absolute Block address.|Parameters data, block_address, auth_mode, key_index	
BlockWrite_AKM1	:	   Write particular block using absolute Block address.|Parameters data, block_address, auth_mode	
BlockWrite_AKM2	:	   Write particular block using absolute Block address.|Parameters data, block_address, auth_mode	
BlockWrite_PK	:	   Write particular block using absolute Block address.|Parameters data, block_address, auth_mode, key	
BlockInSectorRead	:	   Read particular block using relative Block in Sector address.|Parameters data, sector_address, block_in_sector_address, auth_mode, key_index	
BlockInSectorRead_AKM1	:	   Read particular block using relative Block in Sector address.|Parameters data, sector_address, block_in_sector_address, auth_mode	
BlockInSectorRead_AKM2	:	   Read particular block using relative Block in Sector address.|Parameters data, sector_address, block_in_sector_address, auth_mode	
BlockInSectorRead_PK	:	   Read particular block using relative Block in Sector address.|Parameters data, sector_address, block_in_sector_address, auth_mode, key	
BlockInSectorWrite	:	   Write particular block using relative Block in Sector address.|Parameters data, sector_address, block_in_sector_address, auth_mode, key_index	
BlockInSectorWrite_AKM1	:	   Write particular block using relative Block in Sector address.|Parameters data, sector_address, block_in_sector_address, auth_mode	
BlockInSectorWrite_AKM2	:	   Write particular block using relative Block in Sector address.|Parameters data, sector_address, block_in_sector_address, auth_mode	
BlockInSectorWrite_PK	:	   Write particular block using relative Block in Sector address.|Parameters data, sector_address, block_in_sector_address, auth_mode, key	
LinearRead	:	   Group of functions for linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags.|Parameters aucData, usLinearAddress, usDataLength, lpusBytesReturned, ucKeyMode, ucReaderKeyIndex	
LinearRead_AKM1	:	   Group of functions for linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags.|Parameters data, linear_address, length, bytes_returned, auth_mode	
LinearRead_AKM2	:	   Group of functions for linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags.|Parameters data, linear_address, length, bytes_returned, auth_mode	
LinearRead_PK	:	   Group of functions for linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags.|Parameters data, linear_address, length, bytes_returned, auth_mode, key	
LinearWrite	:	   These functions are used for writing data to the card using emulation of the linear address space. The method for proving authenticity is determined by the suffix in the functions names.|Parameters aucData, usLinearAddress, usDataLength, lpusBytesWritten, ucKeyMode, ucReaderKeyIndex	
LinearWrite_AKM1	:	   These functions are used for writing data to the card using emulation of the linear address space. The method for proving authenticity is determined by the suffix in the functions names.|Parameters data, linear_address, length, bytes_written, auth_mode	
LinearWrite_AKM2	:	   These functions are used for writing data to the card using emulation of the linear address space. The method for proving authenticity is determined by the suffix in the functions names.|Parameters data, linear_address, length, bytes_written, auth_mode	
LinearWrite_PK	:	   These functions are used for writing data to the card using emulation of the linear address space. The method for proving authenticity is determined by the suffix in the functions names.|Parameters data, linear_address, length, bytes_written, auth_mode, key	
LinRowRead	:	   Group of functions for linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags.|Parameters aucData, usLinearAddress, usDataLength, lpusBytesReturned, ucKeyMode, ucReaderKeyIndex	
LinRowRead_AKM1	:	   Group of functions for linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags.|Parameters data, linear_address, length, bytes_returned, auth_mode	
LinRowRead_AKM2	:	   Group of functions for linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags.|Parameters data, linear_address, length, bytes_returned, auth_mode	
LinRowRead_PK	:	   Group of functions for linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags.|Parameters data, linear_address, length, bytes_returned, auth_mode, key	
LinearFormatCard	:	   This function is specific to Mifare Classic cards only. It performs Format card operation - write new Sector Trailer values on whole card at once.|Parameters new_key_A, blocks_access_bits, sector_trailers_access_bits, sector_trailers_byte9, new_key_B, lpucSectorsFormatted, auth_mode, key_index	
LinearFormatCard_AKM1	:	   This function is specific to Mifare Classic cards only. It performs Format card operation - write new Sector Trailer values on whole card at once.|Parameters new_key_A, blocks_access_bits, sector_trailers_access_bits, sector_trailers_byte9, new_key_B, lpucSectorsFormatted, auth_mode	
LinearFormatCard_AKM2	:	   This function is specific to Mifare Classic cards only. It performs Format card operation - write new Sector Trailer values on whole card at once.|Parameters new_key_A, blocks_access_bits, sector_trailers_access_bits, sector_trailers_byte9, new_key_B, lpucSectorsFormatted, auth_mode	
LinearFormatCard_PK	:	   This function is specific to Mifare Classic cards only. It performs Format card operation - write new Sector Trailer values on whole card at once.|Parameters new_key_A, blocks_access_bits, sector_trailers_access_bits, sector_trailers_byte9, new_key_B, lpucSectorsFormatted, auth_mode, key	
GetCardSize	:	   Function returns size of user data space on the card (LinearSize), and size of total data space on the card (RawSize). The user data space is accessed via functions LinearWrite and LinearRead. Total data space is accessed via functions LinRowWrite and LinRowRead. For example Mifare Classic 1K card have 752 bytes of user data space (sector trailers and block 0 are not included), and 1024 bytes of total data space.|Parameters lpulLinearSize, lpulRawSize	
SectorTrailerWrite	:	   This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer.|Parameters addressing_mode, address, new_key_A, block0_access_bits, block1_access_bits, block2_access_bits, sector_trailer_access_bits, sector_trailer_byte9, new_key_B, auth_mode, key_index	
SectorTrailerWrite_AKM1	:	   This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer.|Parameters addressing_mode, address, new_key_A, block0_access_bits, block1_access_bits, block2_access_bits, sector_trailer_access_bits, sector_trailer_byte9, new_key_B, auth_mode	
SectorTrailerWrite_AKM2	:	   This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer.|Parameters addressing_mode, address, new_key_A, block0_access_bits, block1_access_bits, block2_access_bits, sector_trailer_access_bits, sector_trailer_byte9, new_key_B, auth_mode	
SectorTrailerWrite_PK	:	   This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer.|Parameters addressing_mode, address, new_key_A, block0_access_bits, block1_access_bits, block2_access_bits, sector_trailer_access_bits, sector_trailer_byte9, new_key_B, auth_mode, key	
SectorTrailerWriteUnsafe	:	   This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer.|Parameters addressing_mode, address, sector_trailer, auth_mode, key_index	
SectorTrailerWriteUnsafe_AKM1	:	   This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. |Parameters addressing_mode, address, sector_trailer, auth_mode	
SectorTrailerWriteUnsafe_AKM2	:	   This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. |Parameters addressing_mode, address, sector_trailer, auth_mode	
SectorTrailerWriteUnsafe_PK	:	   This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. |Parameters addressing_mode, address, sector_trailer, auth_mode, key	
ValueBlockRead	:	   Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format.|Parameters int32_tvalue, value_addr, block_address, auth_mode, key_index	
ValueBlockRead_AKM1	:	   Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format.|Parameters int32_tvalue, value_addr, block_address, auth_mode	
ValueBlockRead_AKM2	:	   Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format.|Parameters int32_tvalue, value_addr, block_address, auth_mode	
ValueBlockRead_PK	:	   Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format.|Parameters int32_tvalue, value_addr, block_address, auth_mode, key	
ValueBlockWrite	:	   Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format.|Parameters int32_tvalue, value_addr, block_address, auth_mode, key_index	
ValueBlockWrite_AKM1	:	   Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format.|Parameters int32_tvalue, value_addr, block_address, auth_mode	
ValueBlockWrite_AKM2	:	   Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format.|Parameters int32_tvalue, value_addr, block_address, auth_mode	
ValueBlockWrite_PK	:	   Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format.|Parameters int32_tvalue, value_addr, block_address, auth_mode, key	
ValueBlockInSectorRead	:	   Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format.|Parameters int32_tvalue, value_addr, sector_address, block_in_sector_address, auth_mode, key_index	
ValueBlockInSectorRead_AKM1	:	   Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format.|Parameters int32_tvalue, value_addr, sector_address, block_in_sector_address, auth_mode	
ValueBlockInSectorRead_AKM2	:	   Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format.|Parameters int32_tvalue, value_addr, sector_address, block_in_sector_address, auth_mode	
ValueBlockInSectorRead_PK	:	   Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format.|Parameters int32_tvalue, value_addr, sector_address, block_in_sector_address, auth_mode, key	
ValueBlockInSectorWrite	:	   Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format.|Parameters int32_tvalue, value_addr, sector_address, block_in_sector_address, auth_mode, key_index	
ValueBlockInSectorWrite_AKM1	:	   Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format.|Parameters int32_tvalue, value_addr, sector_address, block_in_sector_address, auth_mode	
ValueBlockInSectorWrite_AKM2	:	   Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format.|Parameters int32_tvalue, value_addr, sector_address, block_in_sector_address, auth_mode	
ValueBlockInSectorWrite_PK	:	   Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format.|Parameters int32_tvalue, value_addr, sector_address, block_in_sector_address, auth_mode, key	
ValueBlockIncrement	:	   Increments particular Value block with specified value using absolute Block address.|Parameters int32_tincrement_value, block_address, auth_mode, key_index	
ValueBlockIncrement_AKM1	:	   Increments particular Value block with specified value using absolute Block address.|Parameters int32_tincrement_value, block_address, auth_mode	
ValueBlockIncrement_AKM2	:	   Increments particular Value block with specified value using absolute Block address.|Parameters int32_tincrement_value, block_address, auth_mode	
ValueBlockIncrement_PK	:	   Increments particular Value block with specified value using absolute Block address.|Parameters int32_tincrement_value, block_address, auth_mode, key	
ValueBlockDecrement	:	   Decrements particular Value block with specified value using absolute Block address.|Parameters int32_tdecrement_value, block_address, auth_mode, key_index	
ValueBlockDecrement_AKM1	:	   Decrements particular Value block with specified value using absolute Block address.|Parameters int32_tdecrement_value, block_address, auth_mode	
ValueBlockDecrement_AKM2	:	   Decrements particular Value block with specified value using absolute Block address.|Parameters int32_tdecrement_value, block_address, auth_mode	
ValueBlockDecrement_PK	:	   Decrements particular Value block with specified value using absolute Block address.|Parameters int32_tdecrement_value, block_address, auth_mode, key	
write_ndef_record_mirroring	:	   This function works the same as the ?write_ndef_record(),? with the additional UID and / or NFC counter mirror features support. NTAG 21x family of the devices offers these specific features.|Parameters message_nr, tnf, type_record, type_length, id, id_length, payload, payload_length, card_formated, intuse_uid_ascii_mirror, intuse_counter_ascii_mirror, payload_mirroring_pos	
uFR_int_GetDesfireUid	:	   returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). This function returns Unique ID of card, if the Random ID is used.|Parameters aes_key_nr, aid, aid_key_nr, card_uid, card_uid_len, card_status, exec_time	
uFR_int_GetDesfireUid_PK	:	   returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). This function returns Unique ID of card, if the Random ID is used.|Parameters aes_key_ext, aid, aid_key_nr, card_uid, card_uid_len, card_status, exec_time	
uFR_int_DesfireFreeMem	:	   Function returns the available bytes on the card.|Parameters free_mem_byte, card_status, exec_time	
uFR_int_DesfireFormatCard	:	   Function releases all allocated user memory on the card. All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.|Parameters aes_key_nr, card_status, exec_time	
uFR_int_DesfireFormatCard_PK	:	   Function releases all allocated user memory on the card. All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.|Parameters aes_key_ext, card_status, exec_time	
uFR_int_DesfireSetConfiguration	:	   If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.|Parameters aes_key_nr, random_uid, format_disable, card_status, exec_time	
uFR_int_DesfireSetConfiguration_PK	:	   If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.|Parameters aes_key_ext, random_uid, format_disable, card_status, exec_time	
uFR_int_DesfireGetKeySettings	:	   Function allows to get card master key and application master key configuration settings. In addition it returns the maximum number of keys which can be stored within selected application.|Parameters aes_key_nr, aid, setting, max_key_no, card_status, exec_time	
uFR_int_DesfireGetKeySettings_PK	:	   Function allows to get card master key and application master key configuration settings. In addition it returns the maximum number of keys which can be stored within selected application.|Parameters aes_key_ext, aid, setting, max_key_no, card_status, exec_time	
uFR_int_DesfireChangeKeySettings	:	   Function allows to set card master key, and application master key configuration settings.|Parameters aes_key_nr, aid, setting, card_status, exec_time	
uFR_int_DesfireChangeKeySettings_PK	:	   Function allows to set card master key, and application master key configuration settings.|Parameters aes_key_ext, aid, setting, card_status, exec_time	
uFR_int_DesfireChangeAesKey	:	   Function allow to change any AES key on the card. Changing the card master key require current card master key authentication. Authentication for the application keys changing depend on the application master key settings (which key uses for authentication).|Parameters aes_key_nr, aid, aid_key_no_auth, new_aes_key	16], card_status, exec_time";
uFR_int_DesfireChangeAesKey_PK	:	   Function allow to change any AES key on the card. Changing the card master key require current card master key authentication. Authentication for the application keys changing depend on the application master key settings (which key uses for authentication).|Parameters aes_key_ext, aid, aid_key_no_auth, new_aes_key	16], card_status, exec_time";
uFR_int_DesfireChangeAesKey_A	:	   Function allow to change any AES key on the card. Changing the card master key require current card master key authentication. Authentication for the application keys changing depend on the application master key settings (which key uses for authentication).|Parameters aes_key_nr, aid, aid_key_no_auth, new_aes_key_nr, aid_key_no, old_aes_key_nr, card_status, exec_time	
uFR_int_DesfireCreateAesApplication	:	   Function allows to create new application on the card. Is the card master key authentication is required, depend on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to set of up 14 different user definable access keys.|Parameters aes_key_nr, aid, setting, max_key_no, card_status, exec_time	
uFR_int_DesfireCreateAesApplication_PK	:	   Function allows to create new application on the card. Is the card master key authentication is required, depend on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to set of up 14 different user definable access keys.|Parameters aes_key_ext, aid, setting, max_key_no, card_status, exec_time	
uFR_int_DesfireCreateAesApplication_no_auth	:	   Function allows to create new application on the card. Is the card master key authentication is required, depend on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to set of up 14 different user definable access keys.|Parameters aid, setting, max_key_no, card_status, exec_time	
uFR_int_DesfireDeleteApplication	:	   Function allows to deactivate application on the card. Is the card master key authentication is required, depend on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.|Parameters aes_key_nr, aid, card_status, exec_time	
uFR_int_DesfireDeleteApplication_PK	:	   Function allows to deactivate application on the card. Is the card master key authentication is required, depend on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.|Parameters aes_key_ext, aid, card_status, exec_time	
uFR_int_DesfireCreateStdDataFile	:	   Function allows to create file for the storage unformatted user data within existing application on the card. Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.|Parameters aes_key_nr, aid, file_id, file_size, read_key_no, write_key_no, read_write_key_no, change_key_no, communication_settings, card_status, exec_time	
uFR_int_DesfireCreateStdDataFile_PK	:	   Function allows to create file for the storage unformatted user data within existing application on the card. Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.|Parameters aes_key_ext, aid, file_id, file_size, read_key_no, write_key_no, read_write_key_no, change_key_no, communication_settings, card_status, exec_time	
uFR_int_DesfireCreateStdDataFile_no_auth	:	   Function allows to create file for the storage unformatted user data within existing application on the card. Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.|Parameters aid, file_id, file_size, read_key_no, write_key_no, read_write_key_no, change_key_no, communication_settings, card_status, exec_time	
uFR_int_DesfireDeleteFile	:	   Function deactivates a file within currently selected application. Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depend on the application master key settings.|Parameters aes_key_nr, aid, file_id, card_status, exec_time	
uFR_int_DesfireDeleteFile_PK	:	   Function deactivates a file within currently selected application. Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depend on the application master key settings.|Parameters aes_key_ext, aid, file_id, card_status, exec_time	
uFR_int_DesfireDeleteFile_no_auth	:	   Function deactivates a file within currently selected application. Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depend on the application master key settings.|Parameters aid, file_id, card_status, exec_time	
uFR_int_DesfireReadStdDataFile	:	   Function allow to read data from Standard Data File, or from Backup Data File. Read command requires a preceding authentication either with the key specified for Read or Read&Write access.|Parameters aes_key_nr, aid, aid_key_nr, file_id, offset, data_length, communication_settings, data, card_status, exec_time	
uFR_int_DesfireReadStdDataFile_PK	:	   Function allow to read data from Standard Data File, or from Backup Data File. Read command requires a preceding authentication either with the key specified for Read or Read&Write access.|Parameters aes_key_ext, aid, aid_key_nr, file_id, offset, data_length, communication_settings, data, card_status, exec_time	
uFR_int_DesfireReadStdDataFile_no_auth	:	   Function allow to read data from Standard Data File, or from Backup Data File. Read command requires a preceding authentication either with the key specified for Read or Read&Write access.|Parameters aid, aid_key_nr, file_id, offset, data_length, communication_settings, data, card_status, exec_time	
uFR_int_DesfireWriteStdDataFile	:	   Function allow to write data to Standard Data File, or to Backup Data File. Write command requires a preceding authentication either with the key specified for Write or Read&Write access.|Parameters aes_key_nr, aid, aid_key_nr, file_id, offset, data_length, communication_settings, data, card_status, exec_time	
uFR_int_DesfireWriteStdDataFile_PK	:	   Function allow to write data to Standard Data File, or to Backup Data File. Write command requires a preceding authentication either with the key specified for Write or Read&Write access.|Parameters aes_key_ext, aid, aid_key_nr, file_id, offset, data_length, communication_settings, data, card_status, exec_time	
uFR_int_DesfireWriteStdDataFile_no_auth	:	   Function allow to write data to Standard Data File, or to Backup Data File. Write command requires a preceding authentication either with the key specified for Write or Read&Write access.|Parameters aid, aid_key_nr, file_id, offset, data_length, communication_settings, data, card_status, exec_time	
uFR_int_DesfireCreateValueFile	:	   Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.|Parameters aes_key_nr, aid, file_id, int32_tlower_limit, int32_tupper_limit, int32_tvalue, limited_credit_enabled, read_key_no, write_key_no, read_write_key_no, change_key_no, communication_settings, card_status, exec_time	
uFR_int_DesfireCreateValueFile_PK	:	   Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.|Parameters aes_key_ext, aid, file_id, int32_tlower_limit, int32_tupper_limit, int32_tvalue, limited_credit_enabled, read_key_no, write_key_no, read_write_key_no, change_key_no, communication_settings, card_status, exec_time	
uFR_int_DesfireCreateValueFile_no_auth	:	   Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.|Parameters aid, file_id, int32_tlower_limit, int32_tupper_limit, int32_tvalue, limited_credit_enabled, read_key_no, write_key_no, read_write_key_no, change_key_no, communication_settings, card_status, exec_time	
uFR_int_DesfireReadValueFile	:	   Function allow to read value from value files. Read command requires a preceding authentication either with the key specified for Read or Read&Write access.|Parameters aes_key_nr, aid, aid_key_nr, file_id, communication_settings, int32_tvalue, card_status, exec_time	
uFR_int_DesfireReadValueFile_PK	:	   Function allow to read value from value files. Read command requires a preceding authentication either with the key specified for Read or Read&Write access.|Parameters aes_key_ext, aid, aid_key_nr, file_id, communication_settings, int32_tvalue, card_status, exec_time	
uFR_int_DesfireReadValueFile_no_auth	:	   Function allow to read value from value files. Read command requires a preceding authentication either with the key specified for Read or Read&Write access.|Parameters aid, aid_key_nr, file_id, communication_settings, int32_tvalue, card_status, exec_time	
uFR_int_DesfireIncreaseValueFile	:	   Function allows to increase a value stored in a value files. Credit command requires a preceding authentication with the key specified for Read&Write access.|Parameters aes_key_nr, aid, aid_key_nr, file_id, communication_settings, value, card_status, exec_time	
uFR_int_DesfireIncreaseValueFile_PK	:	   Function allows to increase a value stored in a value files. Credit command requires a preceding authentication with the key specified for Read&Write access.|Parameters aes_key_ext, aid, aid_key_nr, file_id, communication_settings, value, card_status, exec_time	
uFR_int_DesfireIncreaseValueFile_no_auth	:	   Function allows to increase a value stored in a value files. Credit command requires a preceding authentication with the key specified for Read&Write access.|Parameters aid, aid_key_nr, file_id, communication_settings, value, card_status, exec_time	
uFR_int_DesfireDecreaseValueFile	:	   Function allow to decrease value from value files. Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.|Parameters aes_key_nr, aid, aid_key_nr, file_id, communication_settings, value, card_status, exec_time	
uFR_int_DesfireDecreaseValueFile_PK	:	   Function allow to decrease value from value files. Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.|Parameters aes_key_ext, aid, aid_key_nr, file_id, communication_settings, value, card_status, exec_time	
uFR_int_DesfireDecreaseValueFile_no_auth	:	   Function allow to decrease value from value files. Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.|Parameters aid, aid_key_nr, file_id, communication_settings, value, card_status, exec_time	
ReadECCSignature	:	   This function returns ECC signature of? the card chip UID. Card chip UID is signed using EC private key known only to a manufacturer.|Parameters lpucECCSignature	MAX_UID_LEN], lpucUidLen, lpucDlogicCardType";
ReadCounter	:	   This function is used to read one of the three 24-bit one-way counters in Ultralight EV1 chip family. Those counters cant be password protected. In the initial Ultralight EV1 chip state, the counter values are set to 0.|Parameters counter_address, value	
IncrementCounter	:	   This function is used to increment one of the three 24-bit one-way counters in Ultralight EV1 chip family. Those counters can't be password protected. If the sum of the addressed counter value and the increment value is higher than 0xFFFFFF, the tag replies with an error and does not update the respective counter.|Parameters counter_address, inc_value	
ReadNFCCounter	:	   This function is used to read 24-bit NFC counter in NTAG 213, NTAG 215 and NTAG 216 chips without using password authentication. If access to NFC counter is configured to be password protected, this function will return COUNTER_ERROR.|Parameters value	
ReadNFCCounterPwdAuth_RK	:	   This function is used to read 24-bit NFC counter in NTAG 213, NTAG 215 and NTAG 216 chips without using password authentication. If access to NFC counter is configured to be password protected, this function will return COUNTER_ERROR.|Parameters value, reader_key_index	
ReadNFCCounterPwdAuth_PK	:	   This function is used to read 24-bit NFC counter in NTAG 213, NTAG 215 and NTAG 216 chips without using password authentication. If access to NFC counter is configured to be password protected, this function will return COUNTER_ERROR.|Parameters value, key	
UfrSetBadSelectCardNrMax	:	   A small value of this parameter may cause a false report that the card is not present, and immediately thereafter true report that the card is present.|Parameters bad_select_nr_max	
UfrGetBadSelectCardNrMax	:	   A small value of this parameter may cause a false report that the card is not present, and immediately thereafter true report that the card is present.|Parameters bad_select_nr_max	
UfrEnterSleepMode	:	   Turn device into Sleep mode.|Parameters No parameters required	
UfrEnterSleepMode	:	   Function allows enter to reader low power working mode. Reader is in sleep mode. RF field is turned off. The reader is waiting for the command to return to normal working mode.|Parameters No parameters required	
UfrLeaveSleepMode	:	   Wake up device from Sleep mode.|Parameters No parameters required	
UfrLeaveSleepMode	:	   Function allows return from low power reader mode to normal working mode.|Parameters No parameters required	
TagEmulationStop	:	   Allows the reader permanent exit from a NDEF tag emulation mode.|Parameters No parameters required	
SetSpeedPermanently	:	   Store a new key or change existing key under provided index parameter.The keys are in a special area in EEPROM that can not be read anymore which gains protection.|Parameters tx_speed, rx_speed	
SetSpeedPermanently	:	   SetSpeedPermanently|Parameters tx_speed, rx_speed	
SetDisplayData	:	   Function enables sending data to the display. A string of data contains information about the intensity of color in each cell of the display. Each cell has three LED (red, green and blue). For each cell of the three bytes is necessary. The first byte indicates the intensity of the green color, the second byte indicates the intensity of the red color, and the third byte indicates the intensity of blue color. For example, if the display has 16 cells, an array contains 48 bytes. Value of intensity is in range from 0 to 255.|Parameters display_data, data_length	
SetDisplayData	:	   This feature working with LED RING 24 display module. Function enables sending data to the display. A string of data contains information about the intensity of color in each cell of the display. Each cell has three LED (red, green and blue). For each cell of the three bytes is necessary. The first byte indicates the intensity of the green color, the second byte indicates the intensity of the red color, and the third byte indicates the intensity of blue color. For example, if the display has 16 cells, an array contains 48 bytes. Value of intensity is in range from 0 to 255.|Parameters display_data, data_length	
EnterShareRamCommMode	:	   Put reader permanently in the mode that use shared RAM. After execution of this function, must be executed function TagEmulationStart.|Parameters No parameters required	
ExitShareRamCommMode	:	   The permanent exit from mode that use shared RAM. After execution of this function, must be executed function TagEmulationStop.|Parameters No parameters required	
WriteShareRam	:	   Function allows writing data to the shared RAM.|Parameters ram_data, addr, data_len	
ReadShareRam	:	   Function allows read data from the shared RAM.|Parameters ram_data, addr, data_len	
AdHocEmulationStart	:	   Put uFR in emulation mode with Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.ad-hoc emulation parameters (see. SetAdHocEmulationParams() and GetAdHocEmulationParams() functions). uFR stays in Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.ad-hoc emulation mode until AdHocEmulationStop() is called or reader reset.|Parameters No parameters required	
AdHocEmulationStop	:	   Terminate uFR ad-hoc emulation mode.|Parameters No parameters required	
GetExternalFieldState	:	   Returns external field state when uFR is in Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.ad-hoc emulation mode.|Parameters is_field_present	
GetAdHocEmulationParams	:	   This function returns current Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.ad-hoc emulation parameters. On uFR power on or reset Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.ad-hoc emulation parameters are set back to their default values.|Parameters ThresholdMinLevel, ThresholdCollLevel, RFLevelAmp, RxGain, RFLevel	
SetAdHocEmulationParams	:	   This command set Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.ad-hoc emulation parameters. On uFR power on or reset Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.ad-hoc emulation parameters are set back to their default values.|Parameters ThresholdMinLevel, ThresholdCollLevel, RFLevelAmp, RxGain, RFLevel	
CombinedModeEmulationStart	:	   Much better control of the NFC device in a uFR proximity range can be achieved using Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.Ad-Hoc emulation mode, described before.|Parameters No parameters required	
r_block_transceive	:	   R-block used to convey positive or negative acknowledgements. An R-block never contains an INF field. The acknowledgement relates to the last received block.|Parameters ack, timeout, rcv_length, rcv_data_array, rcv_chained, ufr_status	
s_block_deselect	:	   S-block used to exchange control information between the PCD and the PICC.|Parameters timeout	
SetISO14443_4_Mode	:	   Some ISO 14443-4 tags supports the APDU message structure according to ISO/IEC 7816-4.|Parameters No parameters required	
UfrXrcLockOn	:	   Electric strike switches when the function called. Pulse duration determined by function.|Parameters pulse_duration	
UfrXrcRelayState	:	   Function switches relay.|Parameters state	
UfrXrcGetIoState	:	   Function returns states of 3 IO pins.|Parameters intercom, door, relay_state	
SetRfAnalogRegistersTypeA	:	   Functions allow adjusting values of registers RFCfgReg and RxThresholdReg. Registry setting is applied to the appropriate type of communication with tag. There are ISO14443 Type A, ISO14443 TypeB, and ISO14443-4 on higher communication speeds (211 and 424 Kbps).|Parameters ThresholdMinLevel, ThresholdCollLevel, RFLevelAmp, RxGain, RFLevel	
SetRfAnalogRegistersTypeB	:	   Functions allow adjusting values of registers RFCfgReg and RxThresholdReg. Registry setting is applied to the appropriate type of communication with tag. There are ISO14443 Type A, ISO14443 TypeB, and ISO14443-4 on higher communication speeds (211 and 424 Kbps).|Parameters ThresholdMinLevel, ThresholdCollLevel, RFLevelAmp, RxGain, RFLevel	
SetRfAnalogRegistersISO14443_212	:	   Functions allow adjusting values of registers RFCfgReg and RxThresholdReg. Registry setting is applied to the appropriate type of communication with tag. There are ISO14443 Type A, ISO14443 TypeB, and ISO14443-4 on higher communication speeds (211 and 424 Kbps).|Parameters ThresholdMinLevel, ThresholdCollLevel, RFLevelAmp, RxGain, RFLevel	
SetRfAnalogRegistersISO14443_424	:	   Functions allow adjusting values of registers RFCfgReg and RxThresholdReg. Registry setting is applied to the appropriate type of communication with tag. There are ISO14443 Type A, ISO14443 TypeB, and ISO14443-4 on higher communication speeds (211 and 424 Kbps).|Parameters ThresholdMinLevel, ThresholdCollLevel, RFLevelAmp, RxGain, RFLevel	
SetRfAnalogRegistersTypeADefault	:	   The functions set the factory default settings of the registers RFCfgReg and RxThresholdReg.|Parameters No parameters required	
SetRfAnalogRegistersTypeBDefault	:	   The functions set the factory default settings of the registers RFCfgReg and RxThresholdReg.|Parameters No parameters required	
SetRfAnalogRegistersISO14443_212Default	:	   The functions set the factory default settings of the registers RFCfgReg and RxThresholdReg.|Parameters No parameters required	
SetRfAnalogRegistersISO14443_424Default	:	   The functions set the factory default settings of the registers RFCfgReg and RxThresholdReg.|Parameters No parameters required	
GetRfAnalogRegistersTypeA	:	   The functions read the value of the registers RFCfgReg and RxThresholdReg.|Parameters ThresholdMinLevel, ThresholdCollLevel, RFLevelAmp, RxGain, RFLevel	
GetRfAnalogRegistersTypeB	:	   The functions read the value of the registers RFCfgReg and RxThresholdReg.|Parameters ThresholdMinLevel, ThresholdCollLevel, RFLevelAmp, RxGain, RFLevel	
GetRfAnalogRegistersISO14443_212	:	   The functions read the value of the registers RFCfgReg and RxThresholdReg.|Parameters ThresholdMinLevel, ThresholdCollLevel, RFLevelAmp, RxGain, RFLevel	
GetRfAnalogRegistersISO14443_424	:	   The functions read the value of the registers RFCfgReg and RxThresholdReg.|Parameters ThresholdMinLevel, ThresholdCollLevel, RFLevelAmp, RxGain, RFLevel	
SetRfAnalogRegistersTypeATrans	:	   Functions allow adjusting values of registers RFCfgReg, RxThresholdReg, GsNOnReg, GsNOffReg, CWGsPReg, ModGsPReg. Registry setting is applied to the appropriate type of communication with tag. There are ISO14443 Type A, ISO14443 TypeB, and Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.ISO14443-4 on higher communication speeds (211 and 424 Kbps).|Parameters ThresholdMinLevel, ThresholdCollLevel, RFLevelAmp, RxGain, RFLevel, CWGsNOn, ModGsNOn, CWGsP, CWGsNOff, ModGsNOff	
SetRfAnalogRegistersTypeBTrans	:	   Functions allow adjusting values of registers RFCfgReg, RxThresholdReg, GsNOnReg, GsNOffReg, CWGsPReg, ModGsPReg. Registry setting is applied to the appropriate type of communication with tag. There are ISO14443 Type A, ISO14443 TypeB, and Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.ISO14443-4 on higher communication speeds (211 and 424 Kbps).|Parameters ThresholdMinLevel, ThresholdCollLevel, RFLevelAmp, RxGain, RFLevel, CWGsNOn, ModGsNOn, CWGsP, ModGsP	
GetRfAnalogRegistersTypeATrans	:	   The functions read the value of the registers RFCfgReg, RxThresholdReg, GsNOnReg, GsNOffReg, CWGsPReg, ModGsPReg.|Parameters ThresholdMinLevel, ThresholdCollLevel, RFLevelAmp, RxGain, RFLevel, CWGsNOn, ModGsNOn, CWGsP, CWGsNOff, ModGsNOff	
GetRfAnalogRegistersTypeBTrans	:	   The functions read the value of the registers RFCfgReg, RxThresholdReg, GsNOnReg, GsNOffReg, CWGsPReg, ModGsPReg.|Parameters ThresholdMinLevel, ThresholdCollLevel, RFLevelAmp, RxGain, RFLevel, CWGsNOn, ModGsNOn, CWGsP, ModGsP	
GreenLedBlinkingTurnOn	:	   The function allows the blinking of the green diode independently of the user's signaling command (default setting).|Parameters No parameters required	
GreenLedBlinkingTurnOff	:	   The function prohibits the blinking of the green diode independently of the user's signaling command. LED and sound signaling occurs only on the user command.|Parameters No parameters required	
SetDisplayData	:	   Function enables sending data to the display. A string of data contains information about the intensity of color in each cell of the display. Each cell has three LED (red, green and blue). For each cell of the three bytes is necessary. The first byte indicates the intensity of the green color, the second byte indicates the intensity of the red color, and the third byte indicates the intensity of blue color. For example, if the display has 16 cells, an array contains 48 bytes. Value of intensity is in range from 0 to 255.|Parameters display_data, data_length	
SetDisplayData	:	   This feature working with LED RING 24 display module. Function enables sending data to the display. A string of data contains information about the intensity of color in each cell of the display. Each cell has three LED (red, green and blue). For each cell of the three bytes is necessary. The first byte indicates the intensity of the green color, the second byte indicates the intensity of the red color, and the third byte indicates the intensity of blue color. For example, if the display has 16 cells, an array contains 48 bytes. Value of intensity is in range from 0 to 255.|Parameters display_data, data_length	
SetDisplayIntensity	:	   Function sets the intensity of light on the display. Value of intensity is in range 0 to 100.|Parameters intensity	
GetDisplayIntensity	:	   Function gets the intensity of light on the display.|Parameters intensity	
ValueBlockInSectorIncrement	:	   Increments particular Value block with specified value using Block in Sector address.|Parameters int32_tincrement_value, sector_address, block_in_sector_address, auth_mode, key_index	
ValueBlockInSectorIncrement_AKM1	:	   Increments particular Value block with specified value using Block in Sector address.|Parameters int32_tincrement_value, sector_address, block_in_sector_address, auth_mode	
ValueBlockInSectorIncrement_AKM2	:	   Increments particular Value block with specified value using Block in Sector address.|Parameters int32_tincrement_value, sector_address, block_in_sector_address, auth_mode	
ValueBlockInSectorIncrement_PK	:	   Increments particular Value block with specified value using Block in Sector address.|Parameters int32_tincrement_value, sector_address, block_in_sector_address, auth_mode, key	
ValueBlockInSectorDecrement	:	   Decrements particular Value block with specified value using Block in Sector address.|Parameters int32_tdecrement_value, sector_address, block_in_sector_address, auth_mode, key_index	
ValueBlockInSectorDecrement_AKM1	:	   Decrements particular Value block with specified value using Block in Sector address.|Parameters int32_tdecrement_value, sector_address, block_in_sector_address, auth_mode	
ValueBlockInSectorDecrement_AKM2	:	   Decrements particular Value block with specified value using Block in Sector address.|Parameters int32_tdecrement_value, sector_address, block_in_sector_address, auth_mode	
ValueBlockInSectorDecrement_PK	:	   Decrements particular Value block with specified value using Block in Sector address.|Parameters int32_tdecrement_value, sector_address, block_in_sector_address, auth_mode, key	
get_ndef_record_count	:	   Function returns the number of NDEF messages that have been read from the card, and number of NDEF records, number of NDEF empty messages. Also, function returns array of bytes containing number of messages pairs. First byte of pair is message ordinal, and second byte is number of NDEF records in that message. Message ordinal starts from 1.|Parameters ndef_message_cnt, ndef_record_cnt, ndef_record_array, empty_ndef_message_cnt	
read_ndef_record	:	   Function returns TNF, type of record, ID and payload from the NDEF record. NDEF record shall be elected by the message ordinal and record ordinal in this message.|Parameters message_nr, record_nr, tnf, type_record, type_length, id, id_length, payload, payload_length	
write_ndef_record	:	   Function adds a record to the end of message, if one or more records already exist in this message. If current message is empty, then this empty record will be replaced with the record. Parameters of function are: ordinal of message, TNF, type of record, ID, payload. Function also returns pointer to the variable which reported that the card formatted for NDEF using (card does not have a capability container, for example new Mifare Ultralight, or Mifare Classic card).|Parameters message_nr, tnf, type_record, type_length, id, id_length, payload, payload_length, card_formated	
erase_last_ndef_record	:	   Function deletes the last record of selected message. If message contains one record, then it will be written empty message.|Parameters message_nr	
erase_all_ndef_records	:	   Function deletes all records of message, then writes empty message.|Parameters message_nr	
ndef_card_initialization	:	   Function prepares the card for NDEF using. Function writes Capability Container (CC) if necessary, and writes empty message. If card is MIFARE CLASSIC or MIFARE PLUS, then function writes MAD (MIFARE Application Directory), and default keys and access bits for NDEF using.|Parameters No parameters required	
GetReaderTime	:	   Function returns 6 bytes array of uint8_t that represented current date and time into device's RTC.|Parameters time	
SetReaderTime	:	   Function sets the date and time into device's RTC. Function requires the 8 bytes password entry to set date and time. Date and time are represent into 6 bytes array in same way as in GetReaderTime function.|Parameters password, time	
ReaderEepromRead	:	   Function returns array of data read from EEPROM. Maximal length of array is 128 bytes.|Parameters data, address, size	
ReaderEepromWrite	:	   Function writes array of data into EEPROM. Maximal length of array is 128 bytes. Function requires password which length is 8 bytes.|Parameters data, address, size, password	
WriteEmulationNdef	:	   Function store a message record for NTAG emulation mode in to the reader.|Parameters tnf, type_record, type_length, id, id_length, payload, payload_length	
TagEmulationStart	:	   Put the reader permanently in a NDEF tag emulation mode. Only way for a reader to exit from this mode is to receive the TAG_EMULATION_STOP command|Parameters No parameters required	
ExitShareRamCommMode	:	   The permanent exit from mode that use shared RAM. After execution of this function, must be executed function TagEmulationStop.|Parameters No parameters required	
uFR_APDU_Transceive	:	   |Parameters cls, ins, p0, p1, data_out, data_out_len, data_in, max_data_in_len, response_len, send_le, apdu_status	
APDUHexStrTransceive	:	   Using this function, you can send CAPDU in the c_string (zero terminated) containing pairs of the hexadecimal digits. Pairs of the hexadecimal digits can be delimited by any of the punctuation characters or white space.|Parameters c_apdu, r_apdu	
APDUPlainTransceive	:	   This is binary alternative function to the APDUHexStrTransceive().|Parameters c_apdu, c_apdu_len, r_apdu, r_apdu_len	
APDUTransceive	:	   This is exploded binary alternative function intended for support APDU commands in ISO 14443-4A tags.|Parameters cls, ins, p0, p1, data_out, Nc, data_in, Ne, send_le, apdu_status	
